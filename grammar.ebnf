(* NOTE: !
  ### Guidelines to convert grammars to source code ###
  1. Each rule R, defined in the grammar, becomes a method with the same name
    References to that rule becomes method calls R(), body of the method follows
    the flow of the body of the rule using the very same guidelines
  2. ORs (such as '(a1 | a2 | aN)' becomes if-elseIf-else statements
  3. Optional groupings '(..)*' becomes a while statement that c an loop over 0
    or more times
  4. Each token reference T becomes a call to the method eat: eat(T). The way
    eat() method works is that it consumes token T if it matches the current
    lookahead token, then it gets a new token from the lexer and assigns that to
    the currentToken internal variable
 *)

(* Start Symbols for grammar *)
file_input: (NEWLINE | statement)*;
interpreter_input: [statement_list] NEWLINE | compound_statement NEWLINE;

(* Compound statements *)
compound_statement: if_statement | while_statement | for_statement | funcdef;
if_statement: "if" expression "{" suite "}"
  ( "elif" expression "{" suite "}" )*
  [ "else" "{" suite "}" ];
while_statement: "while" expression "{" suite "}"
  ["nobreak" "{" suite "}"];
for_statement: "for" target_list "in" expression "{" suite "}" 
  ["nobreak" "{" suite "}"];
funcdef: "func" funcname "(" [parameter_list] ")" [":" integer] "{" suite "}";
parameter_list: defparameter ("," defparameter)*;
defparameter: parameter ["=" expression];
parameter: ident [":" expression];
funcname: ident;
suite: statement_list | NEWLINE statement+;

statement: statement_list NEWLINE | compound_statement;
statement_list: simple_statement (";" simple_statement)* [";"];

(* Simple Statements *)
simple_statement: expression_statement
  | assignment_statement
  | augmented_assignment_statement
  | return_statement
  | break_statement
  | continue_statement;

expression_statement: expression;

assignment_statement: (target_list "=")+ expression;
target_list: target ("," target)*;
target: ident | propertyref | index | slicing;

aug_assignment_statement: target augop expression;
augop: "+=" | "-=" | "/=" | "*=" | "%=";

return_statement: "return" [expression_list];
break_statement: "break";
continue_statement: "continue";

(* Expressions and Literals  *)

IfExpr: Expr ("if" Expr "else" IfExpr)?;

Expr: NotExpr (("||" | "&&") NotExpr)*;
NotExpr: "!" NotExpr | ComparisonExpr;
ComparisonExpr: AddExpr (comparison_op AddExpr)*;
comparison_op: "==" | "!=" | "<" | ">" | "<=" | ">=" | ["!"] "in"

AddExpr: MultExpr (add_op MultExpr)*;
MultExpr: UnExpr (mul_op UnExpr)*;
UnExpr: ("+" | "-") UnExpr | PrimaryExpr;
add_op: "+" | "-";
mul_op: "*" | "/" | "%";

PrimaryExpr: Operand | PrimaryExpr Selector | PrimaryExpr Index | PrimaryExpr Slice | PrimaryExpr Args;
Selector: "." Name;
Index: "[" Expr "]";
Slice: "[ Expr? ":" Expr? (":" Expr?)? "]";
Args: "(" (Expr ("," Expr)* ","?)? ")";

Operand: Literal | Name | "(" Expr ")";
Literal: BasicLit | CompositeLit; // NOTE: FuncLit support in the future?
BasicLit: INT | FLOAT | STR | "true" | "false" | "null"; // NOTE: imaginary support in the future?
CompositeLit: Array | Dict;
Array: "[" (Expr ("," Expr)* ","?)? "]";
Dict: "{" (DictEl ("," DictEl)* ","?)? "}";
DictEl: Key ":" Expr | Name;
Key: Name | str;

NEWLINE: "\n" | "\r\n";
EOF: "EOF";
